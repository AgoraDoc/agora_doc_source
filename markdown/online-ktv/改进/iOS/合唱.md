## 简介

本文介绍如何实现合唱功能。主唱点歌开唱后，伴唱可以和主唱一起唱歌，K 歌房内的听众都可以听到合唱。房间内想与主唱或伴唱连麦语聊的听众可以上麦。

### 技术架构

<pic>

相比独唱，合唱场景中增加了一位或多位伴唱。主唱在发布音乐和人声的音频合流之外，还需要再发布一路人声的音频流，以供伴唱接收，方便伴唱跟随主唱人声进行合唱。



## 实现方法（主唱）

### 1. 设置私有参数


```objective-c
- (void)initializeEngine {
    ....
	// 设置声网私有参数，方便主唱通过 NTP 时间与伴唱进行实时进度同步
    [engine setParameters:@"{\"rtc.ntp_delay_drop_threshold\":1000}"];
    [engine setParameters:@"{\"che.audio.agc.enable\": true}"];
    [engine setParameters:@"{\"rtc.video.enable_sync_render_ntp\": true}"];
    [engine setParameters:@"{\"rtc.net.maxS2LDelay\": 800}"];
}
```

### 2. 开始合唱

```objective-c
- (void)playSong:(NSInteger)songCode
{
    KTVSingRole role = self.config.role;
    KTVSongType type = self.config.type;
    if(type == KTVSongTypeSolo) {
        ....
    } else {
        if(role == KTVSingRoleMainSinger) {
            [self.rtcMediaPlayer openMediaWithSongCode:songCode startPos:0];
            AgoraRtcChannelMediaOptions* options = [AgoraRtcChannelMediaOptions new];
            options.autoSubscribeAudio = YES;
            options.autoSubscribeVideo = YES;
            options.publishMediaPlayerId = [self.rtcMediaPlayer getMediaPlayerId];
            options.publishMediaPlayerAudioTrack = YES;
            options.publishMicrophoneTrack = YES;
            // 合唱场景下，主唱端开启本地音频录制和采集
            options.enableAudioRecordingOrPlayout = YES;
            [self.engine updateChannelWithMediaOptions:options];
            [self joinChorus2ndChannel];

		    // 调整播放器本地和远端所听见的音量
            [self.rtcMediaPlayer adjustPlayoutVolume:50];
            [self.rtcMediaPlayer adjustPublishSignalVolume:50];
        } else if(role == KTVSingRoleCoSinger) {
            ....
        } else {
            ....
        }
    }
}

- (void)joinChorus2ndChannel
{
    if(self.subChorusConnection) {
        KTVLogWarn(@"joinChorus2ndChannel fail! rejoin!");
        return;
    }

    KTVSingRole role = self.config.role;
    AgoraRtcChannelMediaOptions* options = [AgoraRtcChannelMediaOptions new];
    // 主唱不订阅 2nd 频道的音频流
    // 伴唱订阅 2nd 频道的音频流
    options.autoSubscribeAudio = role == KTVSingRoleMainSinger ? NO : YES;
    options.autoSubscribeVideo = NO;
    options.publishMicrophoneTrack = NO;
    // 主唱不开启 2nd 频道的本地录音和播放
    // 伴唱开启 2nd 频道的本地录音和播放
    options.enableAudioRecordingOrPlayout = role == KTVSingRoleMainSinger ? NO : YES;
    options.clientRoleType = AgoraClientRoleBroadcaster;
    // 主唱在 2nd 频道里发布自定义音频流
    // 伴唱在 2nd 频道里不发布自定义音频流
    options.publishDirectCustomAudioTrack = role == KTVSingRoleMainSinger ? YES : NO;;

    AgoraRtcConnection* connection = [AgoraRtcConnection new];
    connection.channelId = [NSString stringWithFormat:@"%@_ex", self.channelName];
    connection.localUid = [VLLoginModel mediaPlayerUidWithUid:VLUserCenter.user.id];
    self.subChorusConnection = connection;

    VL(weakSelf);
    // 设置自定义音频源
    [self.engine setDirectExternalAudioSource:YES];
    [self.engine setAudioFrameDelegate:self];
    // 设置音频属性为合唱
    [self.engine setAudioScenario:AgoraAudioScenarioChorus];
    // 加入 2nd 频道
    [self.engine joinChannelExByToken:VLUserCenter.user.agoraPlayerRTCToken connection:connection delegate:self mediaOptions:options joinSuccess:^(NSString * _Nonnull channel, NSUInteger uid, NSInteger elapsed) {
        // 对合唱场景下的主唱端，设置 pushDirectAudioEnable 为 YES
        if(weakSelf.config.type == KTVSongTypeChorus &&
           weakSelf.config.role == KTVSingRoleMainSinger) {
            weakSelf.pushDirectAudioEnable = YES;
        }

        [weakSelf updateRemotePlayBackVolumeIfNeed];
    }];
}

// 根据音乐播放情况，设置主唱、伴唱、听众的本地播放音量
- (void)updateRemotePlayBackVolumeIfNeed {
    // 对合唱场景下的听众端，本地播放音乐音量设为 100
    if (self.config.type != KTVSongTypeChorus || self.config.role == KTVSingRoleAudience) {
        [self.engine adjustPlaybackSignalVolume:100];
        return;
    }

    // 对合唱场景下的主唱或伴唱端，如果音乐播放器状态为 AgoraMediaPlayerStatePlaying，则本地播放音乐音量设为与远端伴唱或主唱的音量一致
    int volume = self.playerState == AgoraMediaPlayerStatePlaying ? self.chorusRemoteUserVolume : 100;
    if (self.config.role == KTVSingRoleMainSinger) {
        [self.engine adjustPlaybackSignalVolume:volume];
    } else if (self.config.role == KTVSingRoleCoSinger) {
        [self.engine adjustPlaybackSignalVolume:volume];
    }
}

#pragma mark - AgoraAudioFrameDelegate
- (BOOL)onRecordAudioFrame:(AgoraAudioFrame *)frame channelId:(NSString *)channelId
{
    // 如果是合唱场景下的主唱端，发送自定义音频数据给 SDK
    if(self.pushDirectAudioEnable) {
        // 警告：你必须在成功加入 2nd 频道后调用 pushDirectAudioFrameRawData，否则 SDK 可能卡死
        [self.engine pushDirectAudioFrameRawData:frame.buffer samples:frame.channels*frame.samplesPerChannel sampleRate:frame.samplesPerSec channels:frame.channels];
    }
    return true;
}

#pragma RTC delegate for chorus channel2
- (void)rtcEngine:(AgoraRtcEngineKit *)engine didLeaveChannelWithStats:(AgoraChannelStats *)stats
{
    [engine setAudioScenario:AgoraAudioScenarioGameStreaming];
}
```

### 3. 同步播放进度

```objective-c
// 获取音乐总时长
- (NSTimeInterval)getTotalTime {
    if (self.config.role == KTVSingRoleMainSinger) {
        NSTimeInterval time = self.playerDuration;
        return time;
    }
    ....
}

// 获取主唱和伴唱的音乐播放进度
- (NSTimeInterval)getPlayerCurrentTime {
    if (self.config.role == KTVSingRoleMainSinger || self.config.role == KTVSingRoleCoSinger) {
        NSTimeInterval time = uptime() - self.localPlayerPosition;
        return time;
    }

    ....
}

- (NSInteger)playerDuration {
    if (_playerDuration == 0) {
        _playerDuration = [_rtcMediaPlayer getDuration];
    }

    return _playerDuration;
}

- (void)AgoraRtcMediaPlayer:(id<AgoraRtcMediaPlayerProtocol>)playerKit didChangedToPosition:(NSInteger)position
{
    self.localPlayerPosition = uptime() - position;
    // audioPlayoutDelay 是音频播放延迟，即从音频数据发送至接收端，到数据在接收端开始播放所需的时间。
    // 如果是合唱场景下的主播，且播放进度大于音频播放延迟，则通过发送数据流来同步进度。
    if (self.config.role == KTVSingRoleMainSinger && position > self.audioPlayoutDelay) {
        NSDictionary *dict = @{
            @"cmd":@"setLrcTime",
            @"duration":@(self.playerDuration),
            @"time":@(position - self.audioPlayoutDelay),
            @"ntp":@([self getNtpTimeInMs]),
            @"playerState":@(self.playerState)
        };
        [self sendStreamMessageWithDict:dict success:nil];
    }

    ....
}
```

### 4.（可选）退出合唱

```objective-c
- (void)leaveChorus2ndChannel
{
    if(self.subChorusConnection == nil) {
        KTVLogWarn(@"leaveChorus2ndChannel fail connection = nil");
        return;
    }

    [self.engine setDirectExternalAudioSource:NO];
    [self.engine setAudioFrameDelegate:nil];

    KTVSingRole role = self.config.role;
    if(role == KTVSingRoleMainSinger) {
        AgoraRtcChannelMediaOptions* options = [AgoraRtcChannelMediaOptions new];
        options.publishDirectCustomAudioTrack = NO;
        [self.engine updateChannelExWithMediaOptions:options connection:self.subChorusConnection];
        [self.engine leaveChannelEx:self.subChorusConnection leaveChannelBlock:nil];
    } else if(role == KTVSingRoleCoSinger) {
        ....
    }
}
```


## 实现方法（伴唱）

### 1. 加入合唱

```objective-c
- (void)playSong:(NSInteger)songCode
{
    KTVSingRole role = self.config.role;
    KTVSongType type = self.config.type;
    if(type == KTVSongTypeSolo) {
        ....
    } else {
        if(role == KTVSingRoleMainSinger) {
            ....
        } else if(role == KTVSingRoleCoSinger) {
            [self.rtcMediaPlayer openMediaWithSongCode:songCode startPos:0];
            AgoraRtcChannelMediaOptions* options = [AgoraRtcChannelMediaOptions new];
            options.autoSubscribeAudio = YES;
            options.autoSubscribeVideo = YES;
            // 合唱场景下，伴唱不发布播放器音乐
            options.publishMediaPlayerAudioTrack = NO;
            [self.engine updateChannelWithMediaOptions:options];
            [self joinChorus2ndChannel];

            [self.rtcMediaPlayer adjustPlayoutVolume:50];
            [self.rtcMediaPlayer adjustPublishSignalVolume:50];
        } else {
            ....
        }
    }
}

- (void)joinChorus2ndChannel
{
    if(self.subChorusConnection) {
        KTVLogWarn(@"joinChorus2ndChannel fail! rejoin!");
        return;
    }

    KTVSingRole role = self.config.role;
    AgoraRtcChannelMediaOptions* options = [AgoraRtcChannelMediaOptions new];
    // 主唱不订阅 2nd 频道的音频流
    // 伴唱订阅 2nd 频道的音频流
    options.autoSubscribeAudio = role == KTVSingRoleMainSinger ? NO : YES;
    options.autoSubscribeVideo = NO;
    options.publishMicrophoneTrack = NO;
    // 主唱不开启 2nd 频道的本地录音和播放
    // 伴唱开启 2nd 频道的本地录音和播放
    options.enableAudioRecordingOrPlayout = role == KTVSingRoleMainSinger ? NO : YES;
    options.clientRoleType = AgoraClientRoleBroadcaster;
    // 主唱在 2nd 频道里发布自定义音频流
    // 伴唱在 2nd 频道里不发布自定义音频流
    options.publishDirectCustomAudioTrack = role == KTVSingRoleMainSinger ? YES : NO;;

    AgoraRtcConnection* connection = [AgoraRtcConnection new];
    connection.channelId = [NSString stringWithFormat:@"%@_ex", self.channelName];
    connection.localUid = [VLLoginModel mediaPlayerUidWithUid:VLUserCenter.user.id];
    self.subChorusConnection = connection;

    VL(weakSelf);
    // 设置自定义音频源
    [self.engine setDirectExternalAudioSource:YES];
    [self.engine setAudioFrameDelegate:self];
    // 设置音频属性为合唱
    [self.engine setAudioScenario:AgoraAudioScenarioChorus];
    [self.engine joinChannelExByToken:VLUserCenter.user.agoraPlayerRTCToken connection:connection delegate:self mediaOptions:options joinSuccess:^(NSString * _Nonnull channel, NSUInteger uid, NSInteger elapsed) {
        ....
    }];
}


#pragma RTC delegate for chorus channel2
- (void)rtcEngine:(AgoraRtcEngineKit *)engine didLeaveChannelWithStats:(AgoraChannelStats *)stats
{
    [self.engine setAudioScenario:AgoraAudioScenarioGameStreaming];
}
```

### 2. 播放音乐并记录关键时间

```objective-c
- (void)AgoraRtcMediaPlayer:(id<AgoraRtcMediaPlayerProtocol>)playerKit didChangedToPosition:(NSInteger)position
{
    // localPlayerPosition 是系统时间减去播放进度，即播放器开始播放的时间
    self.localPlayerPosition = uptime() - position;

	....
}

// 获取伴唱的音乐播放器的音频播放延迟，即从音频数据发送至接收端，到数据在接收端开始播放所需的时间。
- (void)rtcEngine:(AgoraRtcEngineKit *)engine localAudioStats:(AgoraRtcLocalAudioStats *)stats {
    self.audioPlayoutDelay = stats.audioPlayoutDelay;
}
```

### 3. 校准播放进度

通过 receiveStreamMessageFromUid 回调让伴唱接收主唱的数据流。在该回调中，从接收到的数据解析出主唱的音乐播放进度、音乐总时长、NTP 时间、播放状态。通过 seekToPosition 方法将伴唱的播放进度朝着主唱的播放进度校准。

```objective-c
- (void)rtcEngine:(AgoraRtcEngineKit *)engine receiveStreamMessageFromUid:(NSUInteger)uid streamId:(NSInteger)streamId data:(NSData *)data
{
    // 将数据转换为字典
    NSDictionary *dict = [VLGlobalHelper dictionaryForJsonData:data];
    // 如果 cmd 是 playerPosition
    if ([dict[@"cmd"] isEqualToString:@"playerPosition"]) {
        // 从字典中获取主唱的播放进度、总时长、NTP 时间、播放状态
        NSInteger position = [dict[@"time"] integerValue];
        NSInteger duration = [dict[@"duration"] integerValue];
        NSInteger remoteNtp = [dict[@"ntp"] integerValue];
		AgoraMediaPlayerState state = [dict[@"playerState"] integerValue];
        // 如果当前播放和 cmd 中不同，更新伴唱的播放状态
        if (self.playerState != state) {
            self.playerState = state;
            [self updateCosingerPlayerStatusIfNeed];
            [self.delegate controller:self song:self.config.songCode didChangedToState:state local:NO];
        }

        self.remotePlayerPosition = position;
        self.remotePlayerDuration = duration;
        // 对伴唱，如果音乐播放器正在播放，那么当伴唱的播放进度与主唱的播放进度差距大于 40 ms 时，伴唱音乐播放器通过 seekToPosition 方法调整播放进度。
        if(self.config.type == KTVSongTypeChorus && self.config.role == KTVSingRoleCoSinger) {
            if([self.rtcMediaPlayer getPlayerState] == AgoraMediaPlayerStatePlaying) {
                NSInteger localNtpTime = [self getNtpTimeInMs];
                NSInteger localPosition = uptime() - self.localPlayerPosition;
                NSInteger expectPosition = position + localNtpTime - remoteNtp + self.audioPlayoutDelay;
                NSInteger threshold = expectPosition - localPosition;
                if(labs(threshold) > 40) {
                    [self.rtcMediaPlayer seekToPosition:expectPosition];
                }
            }
        }
    }
}
```

### 4.（可选）退出合唱

退出合唱时，需要结束音频自采集。伴唱还要调用 leaveChannelEx 离开 2nd 频道，恢复订阅主唱的 mixer 音频，按需调节播放器在本地和远端所听见的音量。

```objective-c
- (void)leaveChorus2ndChannel
{
    if(self.subChorusConnection == nil) {
        return;
    }

    [self.engine setDirectExternalAudioSource:NO];
    [self.engine setAudioFrameDelegate:nil];

    KTVSingRole role = self.config.role;
    if(role == KTVSingRoleMainSinger) {
        ....
    } else if(role == KTVSingRoleCoSinger) {
        [self.engine leaveChannelEx:self.subChorusConnection leaveChannelBlock:nil];
        [self.engine muteRemoteAudioStream:self.config.mainSingerUid mute:NO];
    }

    [self adjustPlayoutVolume:self.playoutVolume];
    [self adjustPublishSignalVolume:self.publishSignalVolume];
    self.pushDirectAudioEnable = NO;
    self.subChorusConnection = nil;
}
```

## 实现方法（听众）

相比独唱场景下的听众，合唱场景下的听众只需要再订阅一路伴唱的人声。

